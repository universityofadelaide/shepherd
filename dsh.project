#!/bin/bash

if [ ${HOST_TYPE} != "linux" ]; then
  return
fi

init() {
  # Set some env vars we user in out slightly modified docker-compose files.
  export HOST_SSH_AUTH_SOCK_DIR=$(dirname ${SSH_AUTH_SOCK})
  export CONTAINER_SSH_AUTH_SOCK=/ssh/$(basename ${SSH_AUTH_SOCK})

  # Set default type of OpenShift installation if its not already set.
  : ${OPENSHIFT_TYPE:=minishift}

  # Password for the mysql server.
  SUPER_SECRET_PASSWORD=super-secret-password

  # Path to ssh key with no passphrase.
  : ${BUILD_KEY:=$HOME/.ssh/id_rsa}

  if [ "${OPENSHIFT_TYPE}" == "minishift" ]; then
    # Exit if minishift isn't available.
    if ! which minishift > /dev/null; then
      echo "Minishift not found, is it installed?"
      exit 1
    fi

    # Perform/check setup.
    if [ "$(minishift status)" != "Running" ]; then
      minishift start
    fi

    # Ensure oc command is available.
    eval $(minishift oc-env)
  else
    echo "Using OpenShift in Docker."
  fi

  # Are we logged in.
  if [ ! $(oc whoami) ]; then
    # Prompt for login.
    oc login
  fi

  # If using Minishift, then
  if [ "${OPENSHIFT_TYPE}" == "minishift" ]; then
    # Setup a new mysql server, expose it and group the services.
    if ! oc get svc | grep -q mysql; then
      oc new-app mariadb MYSQL_ROOT_PASSWORD=${SUPER_SECRET_PASSWORD} -l db=shepherd
      oc expose dc mariadb --type=LoadBalancer --name=mysql-external
      oc annotate svc mysql-external "service.alpha.openshift.io/dependencies=[{\"name\": \"mariadb\", \"kind\": \"Service\"}]"
    fi
  else
    echo "Not using Minishift, attempting to use mysql on your host."
  fi

  # Setup the database password in an OpenShift secret.
  if ! oc get secret | grep -q privileged-db-password; then
    oc create secret generic privileged-db-password --from-literal=DATABASE_PASSWORD=${SUPER_SECRET_PASSWORD}
  fi

  # Add local ssh key as build-key secret if it exists and has no passphrase.
  if ! oc get secret | grep -q build-key && [ -f ${BUILD_KEY} ] && ! grep -q ENCRYPTED ${BUILD_KEY}; then
    oc create secret generic build-key --from-file=ssh-privatekey=${BUILD_KEY}
  fi

  # Create a permanent token that shepherd can use to talk to OpenShift.
  if ! oc get serviceaccount | grep -q shepherd; then
    oc create serviceaccount shepherd
    oc policy add-role-to-user admin system:serviceaccount:myproject:shepherd
  fi

  # Retrieve the service account token and the minishift ip.
  SERVICE_ACCOUNT=$(oc describe serviceaccount shepherd | grep Token | awk '{ print $2 }')

  # Now set the things that we need in the dsh shell.
  TOKEN=$(oc describe secret ${SERVICE_ACCOUNT} | grep "token:" | awk '{ print $2 }')
  if [ "${OPENSHIFT_TYPE}" == "minishift" ]; then
    OPENSHIFT_IP=$(minishift ip)
    OPENSHIFT_DOMAIN="${OPENSHIFT_IP}.nip.io"
    OPENSHIFT_URL="https://${OPENSHIFT_IP}:8443"
    DB_HOST="mysql-myproject.${OPENSHIFT_DOMAIN}"
    DB_PORT=$(oc get service mysql-external --no-headers | sed 's/.*:\([0-9]*\).*/\1/')
  else
    OPENSHIFT_IP=$(oc status | grep 'server https' | sed 's/.*https:\/\/\([0-9a-z\.]*\).*/\1/')
    OPENSHIFT_DOMAIN="${OPENSHIFT_IP}.nip.io"
    OPENSHIFT_URL="https://172.17.0.1:8443"
    DB_HOST=172.17.0.1
    DB_PORT=3306
  fi

  # Put everything into the var that dsh passes into the Docker shell.
  DSH_PROJECT=(--env TOKEN=${TOKEN} --env DB_HOST=${DB_HOST} --env DB_PORT=${DB_PORT} --env OPENSHIFT_DOMAIN=${OPENSHIFT_DOMAIN} --env OPENSHIFT_URL=${OPENSHIFT_URL})
}

# Add functionality to the dsh setup/start function
setup_nginx() {
  set +e
  # Test to make sure its not already on the network.
  if ! docker network inspect ${PROJECT}_default | grep "nginx-proxy" > /dev/null; then
    notice "Connecting nginx-proxy to the network."
    docker network connect ${PROJECT}_default nginx-proxy
  fi
  export URL="http://${PROJECT}.${DOMAIN}:8080"
  set -e
}

# Add functionality to the dsh stop function
stop_nginx() {
  if docker network ls | grep "\s${PROJECT}_default" > /dev/null; then
    notice "Disconnecting nginx proxy from network."
    set +e
    docker network disconnect ${PROJECT}_default nginx-proxy
    set -e
  fi
}

# Overridden dsh_shell function
start_shell() {
  if ! docker ps | grep "\s${PROJECT}_web_1" > /dev/null; then
    notice "Project not running, starting."
    dsh_start
  fi

  # Setup docker to run the shell as the current user, thus removing any
  # permission issues.
  if ! docker-compose -f ${DOCKER_COMPOSE_FILE} exec web id -u ${USER} > /dev/null 2>&1; then
    notice "Setting up user $USER on web container."
    # Add user with local $USER name to container.
    docker exec ${PROJECT}_web_1 adduser --disabled-password --uid ${UID} \
      --gecos ${USER} --home /home/${USER} ${USER} > /dev/null
    # Add local .gitconfig to user's home dir on container.
    docker cp ${HOME}/.gitconfig ${PROJECT}_web_1:/home/${USER}/
    # Allow sudo without password for user.
    docker exec ${PROJECT}_web_1 /bin/bash -c "echo '${USER} ALL=(ALL) NOPASSWD: ALL' > /etc/sudoers.d/${USER}"
  fi

  docker-compose -f ${DOCKER_COMPOSE_FILE} exec \
    -u ${USER} \
    -e COLUMNS="$(tput cols)" \
    -e LINES="$(tput lines)" \
    --env SSH_AUTH_SOCK=${CONTAINER_SSH_AUTH_SOCK} \
    ${DSH_PROJECT[@]:-} \
    web ${@:-/bin/bash}

  # Exit here, we don't want to run the dsh shell function now.
  exit
}

COMMAND=${1}

case ${COMMAND} in
  init)
    init
    ;;
  she*)
    shift
    start_shell ${@}
    ;;
  star*)
    setup_nginx
    ;;
  sto*|pur*)
    stop_nginx
    ;;
esac
