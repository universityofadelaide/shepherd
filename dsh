#!/bin/bash

# `set +e` is used to continue on errors throughout this script.
set -euo pipefail

# Used as the prefix for docker networking and container naming.
PROJECT=$(basename "${PWD}")
export PROJECT

# Set some env vars we use in our slightly modified docker-compose files.
HOST_SSH_AUTH_SOCK_DIR=$(dirname "${SSH_AUTH_SOCK}")
export HOST_SSH_AUTH_SOCK_DIR

CONTAINER_SSH_AUTH_SOCK=/ssh/$(basename "${SSH_AUTH_SOCK}")
export CONTAINER_SSH_AUTH_SOCK

# Disable exit on error in case openshift isn't running.
set +e
OPENSHIFT_IP="$(crc ip)"
export OPENSHIFT_IP
set -e

if [ "${GITLAB_CI:-false}" == "true" ]; then
  export DOCKER_COMPOSE_FILE='docker-compose.ci.yml'
else
  export DOCKER_COMPOSE_FILE='docker-compose.linux.yml'
fi

if [ ! -f .env ]; then
  touch .env
fi

# Setup some functions to output warnings.
notice() {
  printf "\e[32;01m%s\e[39;49;00m\n" "$1"
}

warning() {
  printf "\e[33;01m%s\e[39;49;00m\n" "$1"
}

error() {
  printf "\e[31;01m%s\e[39;49;00m\n" "$1"
}

# Ensure script is NOT running inside a container - must be run from host.
if [ -f /.dockerenv ]; then
  error "Inception error - you can't run $0 within a docker container."
  exit 1
fi

dsh_openshift_init() {
  # Password for the mysql server.
  SUPER_SECRET_PASSWORD=super-secret-password

  # Path to ssh key with no passphrase.
  : "${BUILD_KEY:=$HOME/.ssh/id_rsa}"

  # Are we logged in as local developer, if not, bail!
  if [[ $(oc whoami) != "developer" ]]; then
    error "You are not logged in as developer, exiting for safety reasons."
    error "Please login to your local development OpenShift"
    exit 1
  fi

  # Create new namespace/project for Openshift 4.x
  echo "Ensuring shepherd project exists."
  if ! oc get project shepherd > /dev/null 2>&1; then
    oc new-project shepherd
  fi

  echo "Ensuring/switching to the shepherd project."
  if [[ $(oc project -q) != "shepherd" ]]; then
    oc project shepherd
  fi

  # Setup a new mysql server, expose it and group the services.
  echo "Ensuring mariadb service exists"
  if ! oc get svc mariadb > /dev/null 2>&1; then
    oc new-app mariadb MYSQL_ROOT_PASSWORD=${SUPER_SECRET_PASSWORD} -l db=shepherd
    oc expose dc mariadb --type=LoadBalancer --name=mysql-external
    oc annotate svc mysql-external "service.alpha.openshift.io/dependencies=[{\"name\": \"mariadb\", \"kind\": \"Service\"}]"
  fi

  # Setup the database password in an OpenShift secret.
  echo "Ensuring database secret exists."
  if ! oc get secret privileged-db-password > /dev/null 2>&1; then
    oc create secret generic privileged-db-password --from-literal=DATABASE_PASSWORD=${SUPER_SECRET_PASSWORD}
  fi

  # Setup the restic password in an OpenShift secret.
  echo "Ensuring restic secret exists."
  if ! oc get secret shepherd-restic-secret > /dev/null 2>&1; then
    oc create secret generic shepherd-restic-secret --from-literal=password=${SUPER_SECRET_PASSWORD}
  fi

  # Setup the restic PVC for storing backups
  echo "Ensuring restic pvc exists."
  if ! oc get pvc restic-repository > /dev/null 2>&1; then
    oc apply -f ./openshift-config/shepherd-restic-repo-pvc.yml
  fi

  # Setup datagrid config
  echo "Ensuring datagrid config exists."
  if ! oc get configmap datagrid-config > /dev/null 2>&1; then
    # Fails with:
    oc apply -f ./openshift-config/datagrid
  fi

  # Add local ssh key as build-key secret if it exists and has no passphrase.
  echo "Ensuring build secret exists."
  if ! oc get secret build-key > /dev/null 2>&1; then
    if [ -f "${BUILD_KEY}" ] && ! grep -q ENCRYPTED "${BUILD_KEY}"; then
      oc create secret generic build-key --from-file=ssh-privatekey="${BUILD_KEY}"
    else
      echo "build-key passwordless secret not created, builds will likely be broken."
    fi
  fi

  # Create a permanent token that shepherd can use to talk to OpenShift.
  echo "Ensuring serviceaccount exists for token."
  if ! oc get serviceaccount shepherd > /dev/null 2>&1; then
    oc login -u kubeadmin
    oc create serviceaccount shepherd
    oc adm policy add-cluster-role-to-user cluster-admin system:serviceaccount:shepherd:shepherd
    oc adm policy add-cluster-role-to-user self-provisioner system:serviceaccount:shepherd:shepherd
    oc login -u developer
  fi

  # Creating additional service accounts for namespace manipulation.
  echo "Ensuring serviceaccounts exist for provisioning."
  for i in {0..4} ; do
    SA=$(printf 'shepherd-prd-provisioner-00%02d' "$i")
    if ! oc get serviceaccount "${SA}" > /dev/null 2>&1; then
      oc login -u kubeadmin
      oc create serviceaccount "${SA}"
      oc adm policy add-cluster-role-to-user cluster-admin system:serviceaccount:shepherd:"${SA}"
      oc adm policy add-cluster-role-to-user self-provisioner system:serviceaccount:shepherd:"${SA}"
      oc login -u developer

      # This is pretty horrid, but there is no oc command in the dsh shell.
      oc get secret $(oc describe sa ${SA} |\
        grep Token | awk '{ print $2 }') -o json | jq -r '.data.token' | base64 -d > ".${SA}.token"
    fi
  done

  # Retrieve the service account token and the minishift ip.
  SERVICE_ACCOUNT=$(oc describe serviceaccount shepherd | grep Token | awk '{ print $2 }')

  # Now set the things that we need in the dsh shell.
  TOKEN=$(oc describe secret ${SERVICE_ACCOUNT} | grep "token:" | awk '{ print $2 }')
  OPENSHIFT_DOMAIN="apps-crc.testing"
  OPENSHIFT_URL="https://api.crc.testing:6443"
  DB_HOST="mysql-external.${OPENSHIFT_DOMAIN}"
  DB_PORT=$(oc get service mysql-external --no-headers | sed 's/.*:\([0-9]*\).*/\1/')
}

# Command: ./dsh start
# Configures environment then brings up project using docker-compose.yml file.
dsh_start() {
  dsh_openshift_init
  notice "Starting project containers."
  export URL="http://${PROJECT}.${DOMAIN}:8000"
  docker-compose -f ${DOCKER_COMPOSE_FILE} up -d
  notice "Please wait about 10 seconds for the database to settle.
You can now access the site from ${URL}.
Project files are available in /code, You may need to build and install your
  project before it starts working.
Connecting via ./dsh shell and running robo build is a common next step."
}

# Command: ./dsh shell
# Connects a shell to the web image as the current user.
dsh_shell() {
  dsh_start

  docker-compose -f "${DOCKER_COMPOSE_FILE}" exec \
    --env SSH_AUTH_SOCK="${CONTAINER_SSH_AUTH_SOCK}" \
    --env TOKEN=${TOKEN} \
    --env DB_HOST=${DB_HOST} \
    --env DB_PORT=${DB_PORT} \
    --env OPENSHIFT_DOMAIN=${OPENSHIFT_DOMAIN} \
    --env OPENSHIFT_URL=${OPENSHIFT_URL} \
    --env COLUMNS="$(tput cols)" \
    --env LINES="$(tput lines)" \
    web ${@:-/bin/bash}
}

# Command: ./dsh stop
# Stops project and brings down network.
dsh_stop() {
  notice "Stopping containers."
  docker-compose -f ${DOCKER_COMPOSE_FILE} stop
}

# Command: ./dsh purge
# Stops project, then takes down containers and removes volumes if possible.
dsh_purge() {
  docker-compose -f ${DOCKER_COMPOSE_FILE} down -v
}

# Command: ./dsh status
# Shows status information about project containers.
dsh_status() {
  docker-compose -f ${DOCKER_COMPOSE_FILE} ps
}

# Command: ./dsh logs
# Tails logs from web container.
dsh_logs() {
  docker-compose -f ${DOCKER_COMPOSE_FILE} logs -f web
}

# Command: ./dsh pull
# Fetches all images used by the project.
dsh_pull() {
  # docker-compose doesn't resolve sub-dependencies in Dockerfiles.
  docker pull uofa/s2i-shepherd-drupal
  docker-compose -f ${DOCKER_COMPOSE_FILE} pull --ignore-pull-failures
  docker-compose -f ${DOCKER_COMPOSE_FILE} build
}

dsh_help() {
  printf "\nUsage: dsh COMMAND\n
Commands:
\texec\tExecute a command in the docker shell.
\thelp\tShow this help.
\tlogs\tShow the docker logs.
\tpull\tPull the latest docker images down.
\tpurge\tPurge the docker containers, network and proxy and remove all data.
\tshell\tStart a shell which is connected to the containers and can be used to run commands.
\tstart\tStart the docker containers, network and proxy.
\tstatus\tShow the status of this projects containers.
\tstop\tStop the docker containers, network and proxy, but keep data for a re-start.
\nIf no command is given, shell is the default.
Commands can be shortened to their unique component, eg ./dsh sh is the same as ./dsh shell.\n\n"
}

# Set a default command to show usage when no arguments provided.
COMMAND=${1:-default}

case ${COMMAND} in
  e*)
    dsh_shell ${@:2}
    ;;
  h*|-h|--help)
    dsh_help
    ;;
  l*)
    dsh_logs
    ;;
  pul*)
    dsh_pull
    ;;
  pur*)
    dsh_purge
    ;;
  sh*|ss*)
    dsh_shell ${@:2}
    ;;
  star*)
    dsh_start
    ;;
  stat*)
    dsh_status
    ;;
  sto*)
    dsh_stop
    ;;
  *)
    warning "Unknown command specified, defaulting to shell. For other options try:"
    warning "$0 [help|logs|purge|shell|start|status|stop]."
    dsh_shell
    ;;
esac
