#!/bin/bash

# `set +e` is used to continue on errors throughout this script.
set -euo pipefail

# Ensure using 4.10 oc client version.
eval $(crc oc-env)

# Used as the prefix for docker networking and container naming.
PROJECT=$(basename "${PWD}")
export PROJECT

DOMAIN=${DOMAIN:-"172.17.0.1.nip.io"}
export DOMAIN

# Set some env vars we use in our slightly modified docker-compose files.
HOST_SSH_AUTH_SOCK_DIR=$(dirname "${SSH_AUTH_SOCK}")
export HOST_SSH_AUTH_SOCK_DIR

CONTAINER_SSH_AUTH_SOCK=/ssh/$(basename "${SSH_AUTH_SOCK}")
export CONTAINER_SSH_AUTH_SOCK

# Disable exit on error in case openshift isn't running.
set +e
OPENSHIFT_IP="$(crc ip)"
export OPENSHIFT_IP
set -e

if [ "${GITLAB_CI:-false}" == "true" ]; then
  export DOCKER_COMPOSE_FILE='docker-compose.ci.yml'
else
  export DOCKER_COMPOSE_FILE='docker-compose.linux.yml'
fi

if [ ! -f .env ]; then
  touch .env
fi

# Setup some functions to output warnings.
notice() { printf "\e[32;01m%s\e[39;49;00m\n" "$1"; }
warning() { printf "\e[33;01m%s\e[39;49;00m\n" "$1"; }
error() { printf "\e[31;01m%s\e[39;49;00m\n" "$1"; }

# Ensure script is NOT running inside a container - must be run from host.
if [ -f /.dockerenv ]; then
  error "Inception error - you can't run $0 within a docker container."
  exit 1
fi

dsh_openshift_init() {
  # Password for the mysql server.
  SUPER_SECRET_PASSWORD=super-secret-password

  ADMIN_LOGIN=$(crc console --credentials | grep kubeadmin | cut -d"'" -f2)
  DEV_LOGIN=$(crc console --credentials | grep developer | cut -d"'" -f2)

  # Path to ssh key with no passphrase.
  : "${BUILD_KEY:=$HOME/.ssh/id_rsa}"

  # Are we logged in as local developer, if not, bail!
  if [[ $(oc whoami) != "developer" ]]; then
    error "You are not logged in as developer, exiting for safety reasons."
    error "Please login to your local development OpenShift"
    exit 1
  fi

  # Create new namespace/project for Openshift 4.x
  notice "Ensuring shepherd-dev project exists."
  if ! oc get project shepherd-dev > /dev/null 2>&1; then
    oc new-project shepherd-dev
  fi

  notice "Ensuring/switching to the shepherd-dev project."
  if [[ $(oc project -q) != "shepherd-dev" ]]; then
    oc project shepherd-dev
  fi

  # Setup a new mysql server, expose it and group the services.
  notice "Ensuring mariadb service exists"
  if ! oc get svc mariadb > /dev/null 2>&1; then
    oc new-app mariadb MYSQL_ROOT_PASSWORD=${SUPER_SECRET_PASSWORD} -l db=shepherd-dev
    oc expose service mariadb --generator=service/v2 --type=LoadBalancer --name=mysql-external
    oc annotate svc mysql-external "service.alpha.openshift.io/dependencies=[{\"name\": \"mariadb\", \"kind\": \"Service\"}]"
  fi

  # Setup a new minio server, expose it and group the services.
  notice "Ensuring minio service exists"
  oc apply -f deploy/local/minio/

  # Setup the database password in an OpenShift secret.
  notice "Ensuring database secret exists."
  if ! oc get secret privileged-db-password > /dev/null 2>&1; then
    oc create secret generic privileged-db-password --from-literal=DATABASE_PASSWORD=${SUPER_SECRET_PASSWORD}
  fi

  # Setup the restic password in an OpenShift secret.
  notice "Ensuring restic secret exists."
  if ! oc get secret shepherd-dev-restic-secret > /dev/null 2>&1; then
    oc create secret generic shepherd-dev-restic-secret --from-literal=password=${SUPER_SECRET_PASSWORD}
  fi

  # Setup the restic PVC for storing backups
  notice "Ensuring restic pvc exists."
  if ! oc get pvc restic-repository > /dev/null 2>&1; then
    oc apply -f ./openshift-config/shepherd-restic-repo-pvc.yml
  fi

  # Add local ssh key as build-key secret if it exists and has no passphrase.
  notice "Ensuring build secret exists."
  if ! oc get secret build-key > /dev/null 2>&1; then
    if [ -f "${BUILD_KEY}" ] && ! grep -q ENCRYPTED "${BUILD_KEY}"; then
      oc create secret generic build-key --from-file=ssh-privatekey="${BUILD_KEY}"
    else
      warning "build-key passwordless secret not created, builds will likely be broken."
    fi
  fi

  # Create a permanent token that shepherd-dev can use to talk to OpenShift.
  notice "Ensuring serviceaccount exists for token."
  if ! oc get serviceaccount shepherd-sa > /dev/null 2>&1; then
    ${ADMIN_LOGIN}
    oc create serviceaccount shepherd-sa
    oc adm policy add-cluster-role-to-user cluster-admin system:serviceaccount:shepherd-dev:shepherd-sa
    oc adm policy add-cluster-role-to-user self-provisioner system:serviceaccount:shepherd-dev:shepherd-sa
    ${DEV_LOGIN}
  fi

  # Creating additional service accounts for namespace manipulation.
  notice "Ensuring serviceaccounts exist for provisioning."
  for i in {0..4} ; do
    SA=$(printf 'shepherd-dev-provisioner-00%02d' "$i")
    if ! oc get serviceaccount "${SA}" > /dev/null 2>&1; then
      ${ADMIN_LOGIN}
      oc create serviceaccount "${SA}"
      oc adm policy add-cluster-role-to-user cluster-admin system:serviceaccount:shepherd-dev:"${SA}"
      oc adm policy add-cluster-role-to-user self-provisioner system:serviceaccount:shepherd-dev:"${SA}"
      ${DEV_LOGIN}

      # This is pretty horrid, but there is no oc command in the dsh shell.
      oc get secret "$(oc describe sa ${SA} | grep Token | awk '{ print $2 }')" \
         -o json | jq -r '.data.token' | base64 -d > ".${SA}.token"
    fi
  done

  if grep "\"auth\":\"<AUTH>\"" deploy/local/operator/secret.yaml > /dev/null 2>&1; then
    error "Set github token in deploy/local/operator/secret.yaml"
    exit 1
  fi

  ${ADMIN_LOGIN}
  notice "Ensuring datagrid config exists."
  if ! oc get project shepherd-dev-datagrid > /dev/null 2>&1; then
    oc apply -f openshift-config/datagrid/namespace.yml
    oc adm policy add-role-to-user admin developer -n shepherd-dev-datagrid

    if ! command -v helm &> /dev/null; then
      error "helm could not be found. Instructions - https://red.ht/3QVlPzc"
      notice "You will need to configure a Data Grid instance as per the docs in openshift-config/datagrid/supplemental/INSTALL.md"
    else
      oc project shepherd-dev-datagrid
      helm repo add openshift-helm-charts https://charts.openshift.io/
      helm repo update
      helm install data-grid openshift-helm-charts/redhat-data-grid
      oc project shepherd-dev
    fi
  fi
  ${DEV_LOGIN}

  ${ADMIN_LOGIN}
  notice "Ensuring backup operator config exists."
  if ! oc get project shepherd-dev-operator > /dev/null 2>&1; then
    oc apply -f deploy/local/operator/config/manager/namespace.yml
    oc adm policy add-role-to-user admin developer -n shepherd-dev-operator
    oc apply -f deploy/rbac/
    oc apply -f deploy/local/operator/
    oc apply -f deploy/local/operator/config/manager
    oc apply -f deploy/local/operator/config/crd/bases
    oc apply -f deploy/local/operator/config/rbac
  fi
  ${DEV_LOGIN}

  # Retrieve the service account token and the minishift ip.
  SERVICE_ACCOUNT=$(oc describe serviceaccount shepherd-sa | grep Token | awk '{ print $2 }')

  # Now set the things that we need in the dsh shell.
  TOKEN=$(oc describe secret ${SERVICE_ACCOUNT} | grep "token:" | awk '{ print $2 }')
  OPENSHIFT_DOMAIN="apps-crc.testing"
  OPENSHIFT_URL="https://api.crc.testing:6443"
  DB_HOST="mysql-external-shepherd-dev.${OPENSHIFT_DOMAIN}"
  DB_PORT=$(oc get service mysql-external --no-headers | sed 's/.*:\([0-9]*\).*/\1/')
}

# Command: ./dsh start
# Configures environment then brings up project using docker-compose.yml file.
dsh_start() {
  dsh_openshift_init
  notice "Starting project containers."
  export URL="http://${PROJECT}.${DOMAIN}:8000"
  docker-compose -f ${DOCKER_COMPOSE_FILE} up -d
  notice "Please wait about 10 seconds for the database to settle.
You can now access the site from ${URL}.
Project files are available in /code, You may need to build and install your
  project before it starts working.
Connecting via ./dsh shell and running robo build is a common next step."
}

# Command: ./dsh shell
# Connects a shell to the web image as the current user.
dsh_shell() {
  dsh_start

  docker-compose -f "${DOCKER_COMPOSE_FILE}" exec \
    --env SSH_AUTH_SOCK="${CONTAINER_SSH_AUTH_SOCK}" \
    --env TOKEN=${TOKEN} \
    --env DB_HOST=${DB_HOST} \
    --env DB_PORT=${DB_PORT} \
    --env OPENSHIFT_DOMAIN=${OPENSHIFT_DOMAIN} \
    --env OPENSHIFT_URL=${OPENSHIFT_URL} \
    --env COLUMNS="$(tput cols)" \
    --env LINES="$(tput lines)" \
    web ${@:-/bin/bash}
}

# Command: ./dsh stop
# Stops project and brings down network.
dsh_stop() {
  notice "Stopping containers."
  docker-compose -f ${DOCKER_COMPOSE_FILE} stop
}

# Command: ./dsh purge
# Stops project, then takes down containers and removes volumes if possible.
dsh_purge() {
  docker-compose -f ${DOCKER_COMPOSE_FILE} down -v
}

# Command: ./dsh status
# Shows status information about project containers.
dsh_status() {
  docker-compose -f ${DOCKER_COMPOSE_FILE} ps
}

# Command: ./dsh logs
# Tails logs from web container.
dsh_logs() {
  docker-compose -f ${DOCKER_COMPOSE_FILE} logs -f web
}

# Command: ./dsh pull
# Fetches all images used by the project.
dsh_pull() {
  # docker-compose doesn't resolve sub-dependencies in Dockerfiles.
  docker pull uofa/s2i-shepherd-drupal
  docker-compose -f ${DOCKER_COMPOSE_FILE} pull --ignore-pull-failures
  docker-compose -f ${DOCKER_COMPOSE_FILE} build
}

dsh_help() {
  printf "\nUsage: dsh COMMAND\n
Commands:
\texec\tExecute a command in the docker shell.
\thelp\tShow this help.
\tlogs\tShow the docker logs.
\tpull\tPull the latest docker images down.
\tpurge\tPurge the docker containers, network and proxy and remove all data.
\tshell\tStart a shell which is connected to the containers and can be used to run commands.
\tstart\tStart the docker containers, network and proxy.
\tstatus\tShow the status of this projects containers.
\tstop\tStop the docker containers, network and proxy, but keep data for a re-start.
\nIf no command is given, shell is the default.
Commands can be shortened to their unique component, eg ./dsh sh is the same as ./dsh shell.\n\n"
}

# Set a default command to show usage when no arguments provided.
COMMAND=${1:-default}

case ${COMMAND} in
  e*)
    dsh_shell ${@:2}
    ;;
  h*|-h|--help)
    dsh_help
    ;;
  l*)
    dsh_logs
    ;;
  pul*)
    dsh_pull
    ;;
  pur*)
    dsh_purge
    ;;
  sh*|ss*)
    dsh_shell ${@:2}
    ;;
  star*)
    dsh_start
    ;;
  stat*)
    dsh_status
    ;;
  sto*)
    dsh_stop
    ;;
  *)
    warning "Unknown command specified, defaulting to shell. For other options try:"
    warning "$0 [help|logs|purge|shell|start|status|stop]."
    dsh_shell
    ;;
esac
